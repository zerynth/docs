# Amazon Web Services IoT FOTA Library

The Zerynth AWS IoT FOTA Library can be used to implement Firmware Over The Air updates (FOTA) of AWS Things with ease.

Devices connected to the AWS IoT MQTT Broker can receive jobs containing enough information for a firmware update. Such jobs can be easily generated by the ZTC.

The FOTA flow is quite simple:


* A device is notified of a new job


* The job document must contain the following required fields:

> 
>     * `bc_idx`, the index of the bytecode slot to save the new firmware to


>     * `bc_crc`, the MD5 crc of the new firmware


>     * `bc_size`, the length in bytes of the new firmware


>     * `bc_url`, a https url to a S3 file containing the new firmware


* If the job can be performed, it is placed in the IN_PROGRESS status. Otherwise it is mared as FAILED and the flow stops.


* The firmware is downloaded from `bc_url`, saved to the device and checked for errors against `bc_crc`


* The device is restarted


* If the new firmware is correct, the IN_PROGRESS job is retrieved and marked as SUCCEEDED. Otherwise the old working firmware will restart and will mark the job as FAILED.

The entire flow can be managed as in the following example:

```
from aws.iot import fota as awsfota
from aws.iot import jobs

...
do some initialization (connect to the network and configure the Thing)
...

# create an IoT Jobs object
myjobs = jobs.Jobs(thing)

# check if there are FOTA jobs waiting to be performed
# This function executes a FOTA update if possible
# or confirms an already executed FOTA update
awsfota.handle_fota_jobs(myjobs, force=True)  # True, force

while True:
    r = random(0,10)
    print('publish random sample...',r)
    thing.mqtt.publish("dev/sample", json.dumps({ 'asample': r }))
    sleep(publish_period)

    # check for new incoming jobs
    # again, FOTA is executed if a correct FOTA job is queued
    awsfota.handle_fota_jobs(myjobs)
```


---
#### `#!py3 update()`

!!!abstract "`#!py3 update(document)`"

Given a correct job `document`, performs the FOTA update by downloading the correct firmware from the signed S3 bucket url
and checking if the download was correct against the firmware CRC. Return True if the process finishes correctly.


---
#### `#!py3 test()`

!!!abstract "`#!py3 test(document)`"

Must be called after a successful update to test the new firmware providing the job `document`. Once called, a device reset is necessary.


---
#### `#!py3 confirm()`

!!!abstract "`#!py3 confirm()`"

Makes the new firmware final. Must be called by the new firmware upon reset after the old firmware called test. Failing to confirm the new firmware will reboot the old firmware on reset.


---
#### `#!py3 reset()`

!!!abstract "`#!py3 reset()`"

Reset the device


---
#### `#!py3 handle_fota_jobs()`

!!!abstract "`#!py3 handle_fota_jobs(jobs, force=False, disconnect_mqtt=True, auto_reset=True, job_cbk=None)`"

The entire FOTA flow can be implemented by adding this function to an AWS ready firmware.

The function arguments:


* `jobs`, is an instance of the Jobs class (module aws.iot.jobs) properly initialized with the current Thing


* `force`, if True forces the retrieval of pending and queued jobs regardless of a mqtt notification of the new jobs event


* `disconnect_mqtt`, determines if th mqtt connection of the current Thing is closed before attempting a FOTA. By default it is set to True since keeping two TLS sockets open (one to the MQTT broker and the other to the S3 bucket) can be demanding for most devices.


* `auto_reset`, automatically resets the device when the FOTA flow requires it. By default is set to True, however it can be disabled and the needed reset can be performed manually. A reset is signaled by handle_fota_jobs returning True.


* `job_cbk`, is the job callback. Each non-FOTA job is passed to `job_cbk` for external handling if `job_cbk` is not None

The function must be called at least twice: the first time, right after the connection to the mqtt broker with `force=True` in order to handle all pending jobs. The second call can be made periodically in the publish loop to catch new queued jobs.
